'use strict';
'use babel';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNodePrefixPath = getNodePrefixPath;
exports.findESLintDirectory = findESLintDirectory;
exports.getESLintFromDirectory = getESLintFromDirectory;
exports.refreshModulesPath = refreshModulesPath;
exports.getESLintInstance = getESLintInstance;
exports.getConfigPath = getConfigPath;
exports.getRelativePath = getRelativePath;
exports.getCLIEngineOptions = getCLIEngineOptions;
exports.getRules = getRules;
exports.didRulesChange = didRulesChange;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _fsPlus = require('fs-plus');

var _fsPlus2 = _interopRequireDefault(_fsPlus);

var _child_process = require('child_process');

var _child_process2 = _interopRequireDefault(_child_process);

var _resolveEnv = require('resolve-env');

var _resolveEnv2 = _interopRequireDefault(_resolveEnv);

var _atomLinter = require('atom-linter');

var _consistentPath = require('consistent-path');

var _consistentPath2 = _interopRequireDefault(_consistentPath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const Cache = {
  ESLINT_LOCAL_PATH: _path2.default.normalize(_path2.default.join(__dirname, '..', 'node_modules', 'eslint')),
  NODE_PREFIX_PATH: null,
  LAST_MODULES_PATH: null

  /**
   * Takes a path and translates `~` to the user's home directory, and replaces
   * all environment variables with their value.
   * @param  {string} path The path to remove "strangeness" from
   * @return {string}      The cleaned path
   */
};const cleanPath = path => path ? (0, _resolveEnv2.default)(_fsPlus2.default.normalize(path)) : '';

function getNodePrefixPath() {
  if (Cache.NODE_PREFIX_PATH === null) {
    const npmCommand = process.platform === 'win32' ? 'npm.cmd' : 'npm';
    try {
      Cache.NODE_PREFIX_PATH = _child_process2.default.spawnSync(npmCommand, ['get', 'prefix'], {
        env: Object.assign(Object.assign({}, process.env), { PATH: (0, _consistentPath2.default)() })
      }).output[1].toString().trim();
    } catch (e) {
      const errMsg = 'Unable to execute `npm get prefix`. Please make sure ' + 'Atom is getting $PATH correctly.';
      throw new Error(errMsg);
    }
  }
  return Cache.NODE_PREFIX_PATH;
}

function isDirectory(dirPath) {
  let isDir;
  try {
    isDir = _fsPlus2.default.statSync(dirPath).isDirectory();
  } catch (e) {
    isDir = false;
  }
  return isDir;
}

function findESLintDirectory(modulesDir, config, projectPath) {
  let eslintDir = null;
  let locationType = null;
  if (config.global.useGlobalEslint) {
    locationType = 'global';
    const configGlobal = cleanPath(config.global.globalNodePath);
    const prefixPath = configGlobal || getNodePrefixPath();
    // NPM on Windows and Yarn on all platforms
    eslintDir = _path2.default.join(prefixPath, 'node_modules', 'eslint');
    if (!isDirectory(eslintDir)) {
      // NPM on platforms other than Windows
      eslintDir = _path2.default.join(prefixPath, 'lib', 'node_modules', 'eslint');
    }
  } else if (!config.advanced.localNodeModules) {
    locationType = 'local project';
    eslintDir = _path2.default.join(modulesDir || '', 'eslint');
  } else if (_path2.default.isAbsolute(cleanPath(config.advanced.localNodeModules))) {
    locationType = 'advanced specified';
    eslintDir = _path2.default.join(cleanPath(config.advanced.localNodeModules), 'eslint');
  } else {
    locationType = 'advanced specified';
    eslintDir = _path2.default.join(projectPath || '', cleanPath(config.advanced.localNodeModules), 'eslint');
  }

  if (isDirectory(eslintDir)) {
    return {
      path: eslintDir,
      type: locationType
    };
  }

  if (config.global.useGlobalEslint) {
    throw new Error('ESLint not found, please ensure the global Node path is set correctly.');
  }

  return {
    path: Cache.ESLINT_LOCAL_PATH,
    type: 'bundled fallback'
  };
}

function getESLintFromDirectory(modulesDir, config, projectPath) {
  const { path: ESLintDirectory } = findESLintDirectory(modulesDir, config, projectPath);
  try {
    // eslint-disable-next-line import/no-dynamic-require
    return require(ESLintDirectory);
  } catch (e) {
    if (config.global.useGlobalEslint && e.code === 'MODULE_NOT_FOUND') {
      throw new Error('ESLint not found, try restarting Atom to clear caches.');
    }
    // eslint-disable-next-line import/no-dynamic-require
    return require(Cache.ESLINT_LOCAL_PATH);
  }
}

function refreshModulesPath(modulesDir) {
  if (Cache.LAST_MODULES_PATH !== modulesDir) {
    Cache.LAST_MODULES_PATH = modulesDir;
    process.env.NODE_PATH = modulesDir || '';
    // eslint-disable-next-line no-underscore-dangle
    require('module').Module._initPaths();
  }
}

function getESLintInstance(fileDir, config, projectPath) {
  const modulesDir = _path2.default.dirname((0, _atomLinter.findCached)(fileDir, 'node_modules/eslint') || '');
  refreshModulesPath(modulesDir);
  return getESLintFromDirectory(modulesDir, config, projectPath);
}

function getConfigPath(fileDir) {
  const configFile = (0, _atomLinter.findCached)(fileDir, ['.eslintrc.js', '.eslintrc.yaml', '.eslintrc.yml', '.eslintrc.json', '.eslintrc', 'package.json']);
  if (configFile) {
    if (_path2.default.basename(configFile) === 'package.json') {
      // eslint-disable-next-line import/no-dynamic-require
      if (require(configFile).eslintConfig) {
        return configFile;
      }
      // If we are here, we found a package.json without an eslint config
      // in a dir without any other eslint config files
      // (because 'package.json' is last in the call to findCached)
      // So, keep looking from the parent directory
      return getConfigPath(_path2.default.resolve(_path2.default.dirname(configFile), '..'));
    }
    return configFile;
  }
  return null;
}

function getRelativePath(fileDir, filePath, config, projectPath) {
  const ignoreFile = config.advanced.disableEslintIgnore ? null : (0, _atomLinter.findCached)(fileDir, '.eslintignore');

  // If we can find an .eslintignore file, we can set cwd there
  // (because they are expected to be at the project root)
  if (ignoreFile) {
    const ignoreDir = _path2.default.dirname(ignoreFile);
    process.chdir(ignoreDir);
    return _path2.default.relative(ignoreDir, filePath);
  }
  // Otherwise, we'll set the cwd to the atom project root as long as that exists
  if (projectPath) {
    process.chdir(projectPath);
    return _path2.default.relative(projectPath, filePath);
  }
  // If all else fails, use the file location itself
  process.chdir(fileDir);
  return _path2.default.basename(filePath);
}

function getCLIEngineOptions(type, config, rules, filePath, fileDir, givenConfigPath) {
  const cliEngineConfig = {
    rules,
    ignore: !config.advanced.disableEslintIgnore,
    fix: type === 'fix'
  };

  const ignoreFile = config.advanced.disableEslintIgnore ? null : (0, _atomLinter.findCached)(fileDir, '.eslintignore');
  if (ignoreFile) {
    cliEngineConfig.ignorePath = ignoreFile;
  }

  cliEngineConfig.rulePaths = config.advanced.eslintRulesDirs.map(path => {
    const rulesDir = cleanPath(path);
    if (!_path2.default.isAbsolute(rulesDir)) {
      return (0, _atomLinter.findCached)(fileDir, rulesDir);
    }
    return rulesDir;
  }).filter(path => path);

  if (givenConfigPath === null && config.global.eslintrcPath) {
    // If we didn't find a configuration use the fallback from the settings
    cliEngineConfig.configFile = cleanPath(config.global.eslintrcPath);
  }

  return cliEngineConfig;
}

/**
 * Gets the list of rules used for a lint job
 * @param  {Object} cliEngine The CLIEngine instance used for the lint job
 * @return {Map}              A Map of the rules used, rule names as keys, rule
 *                            properties as the contents.
 */
function getRules(cliEngine) {
  // Pull the list of rules used directly from the CLIEngine
  // Added in https://github.com/eslint/eslint/pull/9782
  if (Object.prototype.hasOwnProperty.call(cliEngine, 'getRules')) {
    return cliEngine.getRules();
  }

  // Attempt to use the internal (undocumented) `linter` instance attached to
  // the CLIEngine to get the loaded rules (including plugin rules).
  // Added in ESLint v4
  if (Object.prototype.hasOwnProperty.call(cliEngine, 'linter')) {
    return cliEngine.linter.getRules();
  }

  // Older versions of ESLint don't (easily) support getting a list of rules
  return new Map();
}

/**
 * Given an exiting rule list and a new rule list, determines whether there
 * have been changes.
 * NOTE: This only accounts for presence of the rules, changes to their metadata
 * are not taken into account.
 * @param  {Map} newRules     A Map of the new rules
 * @param  {Map} currentRules A Map of the current rules
 * @return {boolean}             Whether or not there were changes
 */
function didRulesChange(currentRules, newRules) {
  return !(currentRules.size === newRules.size && Array.from(currentRules.keys()).every(ruleId => newRules.has(ruleId)));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndvcmtlci1oZWxwZXJzLmpzIl0sIm5hbWVzIjpbImdldE5vZGVQcmVmaXhQYXRoIiwiZmluZEVTTGludERpcmVjdG9yeSIsImdldEVTTGludEZyb21EaXJlY3RvcnkiLCJyZWZyZXNoTW9kdWxlc1BhdGgiLCJnZXRFU0xpbnRJbnN0YW5jZSIsImdldENvbmZpZ1BhdGgiLCJnZXRSZWxhdGl2ZVBhdGgiLCJnZXRDTElFbmdpbmVPcHRpb25zIiwiZ2V0UnVsZXMiLCJkaWRSdWxlc0NoYW5nZSIsIkNhY2hlIiwiRVNMSU5UX0xPQ0FMX1BBVEgiLCJQYXRoIiwibm9ybWFsaXplIiwiam9pbiIsIl9fZGlybmFtZSIsIk5PREVfUFJFRklYX1BBVEgiLCJMQVNUX01PRFVMRVNfUEFUSCIsImNsZWFuUGF0aCIsInBhdGgiLCJmcyIsIm5wbUNvbW1hbmQiLCJwcm9jZXNzIiwicGxhdGZvcm0iLCJDaGlsZFByb2Nlc3MiLCJzcGF3blN5bmMiLCJlbnYiLCJPYmplY3QiLCJhc3NpZ24iLCJQQVRIIiwib3V0cHV0IiwidG9TdHJpbmciLCJ0cmltIiwiZSIsImVyck1zZyIsIkVycm9yIiwiaXNEaXJlY3RvcnkiLCJkaXJQYXRoIiwiaXNEaXIiLCJzdGF0U3luYyIsIm1vZHVsZXNEaXIiLCJjb25maWciLCJwcm9qZWN0UGF0aCIsImVzbGludERpciIsImxvY2F0aW9uVHlwZSIsImdsb2JhbCIsInVzZUdsb2JhbEVzbGludCIsImNvbmZpZ0dsb2JhbCIsImdsb2JhbE5vZGVQYXRoIiwicHJlZml4UGF0aCIsImFkdmFuY2VkIiwibG9jYWxOb2RlTW9kdWxlcyIsImlzQWJzb2x1dGUiLCJ0eXBlIiwiRVNMaW50RGlyZWN0b3J5IiwicmVxdWlyZSIsImNvZGUiLCJOT0RFX1BBVEgiLCJNb2R1bGUiLCJfaW5pdFBhdGhzIiwiZmlsZURpciIsImRpcm5hbWUiLCJjb25maWdGaWxlIiwiYmFzZW5hbWUiLCJlc2xpbnRDb25maWciLCJyZXNvbHZlIiwiZmlsZVBhdGgiLCJpZ25vcmVGaWxlIiwiZGlzYWJsZUVzbGludElnbm9yZSIsImlnbm9yZURpciIsImNoZGlyIiwicmVsYXRpdmUiLCJydWxlcyIsImdpdmVuQ29uZmlnUGF0aCIsImNsaUVuZ2luZUNvbmZpZyIsImlnbm9yZSIsImZpeCIsImlnbm9yZVBhdGgiLCJydWxlUGF0aHMiLCJlc2xpbnRSdWxlc0RpcnMiLCJtYXAiLCJydWxlc0RpciIsImZpbHRlciIsImVzbGludHJjUGF0aCIsImNsaUVuZ2luZSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImxpbnRlciIsIk1hcCIsImN1cnJlbnRSdWxlcyIsIm5ld1J1bGVzIiwic2l6ZSIsIkFycmF5IiwiZnJvbSIsImtleXMiLCJldmVyeSIsInJ1bGVJZCIsImhhcyJdLCJtYXBwaW5ncyI6IjtBQUFBOzs7OztRQXVCZ0JBLGlCLEdBQUFBLGlCO1FBMEJBQyxtQixHQUFBQSxtQjtRQXlDQUMsc0IsR0FBQUEsc0I7UUFjQUMsa0IsR0FBQUEsa0I7UUFTQUMsaUIsR0FBQUEsaUI7UUFNQUMsYSxHQUFBQSxhO1FBcUJBQyxlLEdBQUFBLGU7UUFvQkFDLG1CLEdBQUFBLG1CO1FBa0NBQyxRLEdBQUFBLFE7UUEyQkFDLGMsR0FBQUEsYzs7QUEzTmhCOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7OztBQUVBLE1BQU1DLFFBQVE7QUFDWkMscUJBQW1CQyxlQUFLQyxTQUFMLENBQWVELGVBQUtFLElBQUwsQ0FBVUMsU0FBVixFQUFxQixJQUFyQixFQUEyQixjQUEzQixFQUEyQyxRQUEzQyxDQUFmLENBRFA7QUFFWkMsb0JBQWtCLElBRk47QUFHWkMscUJBQW1COztBQUdyQjs7Ozs7O0FBTmMsQ0FBZCxDQVlBLE1BQU1DLFlBQVlDLFFBQVNBLE9BQU8sMEJBQVdDLGlCQUFHUCxTQUFILENBQWFNLElBQWIsQ0FBWCxDQUFQLEdBQXdDLEVBQW5FOztBQUVPLFNBQVNuQixpQkFBVCxHQUE2QjtBQUNsQyxNQUFJVSxNQUFNTSxnQkFBTixLQUEyQixJ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U2xFLFFBQVQsQ0FBa0I0RSxTQUFsQixFQUE2QjtBQUNsQztBQUNBO0FBQ0EsTUFBSXpELE9BQU8wRCxTQUFQLENBQWlCQyxjQUFqQixDQUFnQ0MsSUFBaEMsQ0FBcUNILFNBQXJDLEVBQWdELFVBQWhELENBQUosRUFBaUU7QUFDL0QsV0FBT0EsVUFBVTVFLFFBQVYsRUFBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBLE1BQUltQixPQUFPMEQsU0FBUCxDQUFpQkMsY0FBakIsQ0FBZ0NDLElBQWhDLENBQXFDSCxTQUFyQyxFQUFnRCxRQUFoRCxDQUFKLEVBQStEO0FBQzdELFdBQU9BLFVBQVVJLE1BQVYsQ0FBaUJoRixRQUFqQixFQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxTQUFPLElBQUlpRixHQUFKLEVBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7O0FBU08sU0FBU2hGLGNBQVQsQ0FBd0JpRixZQUF4QixFQUFzQ0MsUUFBdEMsRUFBZ0Q7QUFDckQsU0FBTyxFQUFFRCxhQUFhRSxJQUFiLEtBQXNCRCxTQUFTQyxJQUEvQixJQUNKQyxNQUFNQyxJQUFOLENBQVdKLGFBQWFLLElBQWIsRUFBWCxFQUFnQ0MsS0FBaEMsQ0FBc0NDLFVBQVVOLFNBQVNPLEdBQVQsQ0FBYUQsTUFBYixDQUFoRCxDQURFLENBQVA7QUFFRCIsImZpbGUiOiJ3b3JrZXItaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIvVXNlcnMvd2lsbC9kb3RmaWxlcy8uYXRvbS9wYWNrYWdlcy9saW50ZXItZXNsaW50L3NyYyIsInNvdXJjZXNDb250ZW50IjpbIid1c2UgYmFiZWwnXG5cbmltcG9ydCBQYXRoIGZyb20gJ3BhdGgnXG5pbXBvcnQgZnMgZnJvbSAnZnMtcGx1cydcbmltcG9ydCBDaGlsZFByb2Nlc3MgZnJvbSAnY2hpbGRfcHJvY2VzcydcbmltcG9ydCByZXNvbHZlRW52IGZyb20gJ3Jlc29sdmUtZW52J1xuaW1wb3J0IHsgZmluZENhY2hlZCB9IGZyb20gJ2F0b20tbGludGVyJ1xuaW1wb3J0IGdldFBhdGggZnJvbSAnY29uc2lzdGVudC1wYXRoJ1xuXG5jb25zdCBDYWNoZSA9IHtcbiAgRVNMSU5UX0xPQ0FMX1BBVEg6IFBhdGgubm9ybWFsaXplKFBhdGguam9pbihfX2Rpcm5hbWUsICcuLicsICdub2RlX21vZHVsZXMnLCAnZXNsaW50JykpLFxuICBOT0RFX1BSRUZJWF9QQVRIOiBudWxsLFxuICBMQVNUX01PRFVMRVNfUEFUSDogbnVsbFxufVxuXG4vKipcbiAqIFRha2VzIGEgcGF0aCBhbmQgdHJhbnNsYXRlcyBgfmAgdG8gdGhlIHVzZXIncyBob21lIGRpcmVjdG9yeSwgYW5kIHJlcGxhY2VzXG4gKiBhbGwgZW52aXJvbm1lbnQgdmFyaWFibGVzIHdpdGggdGhlaXIgdmFsdWUuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gcmVtb3ZlIFwic3RyYW5nZW5lc3NcIiBmcm9tXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgVGhlIGNsZWFuZWQgcGF0aFxuICovXG5jb25zdCBjbGVhblBhdGggPSBwYXRoID0+IChwYXRoID8gcmVzb2x2ZUVudihmcy5ub3JtYWxpemUocGF0aCkpIDogJycpXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlUHJlZml4UGF0aCgpIHtcbiAgaWYgKENhY2hlLk5PREVfUFJFRklYX1BBVEggPT09IG51bGwpIHtcbiAgICBjb25zdCBucG1Db21tYW5kID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/ICducG0uY21kJyA6ICducG0nXG4gICAgdHJ5IHtcbiAgICAgIENhY2hlLk5PREVfUFJFRklYX1BBVEggPSBDaGlsZFByb2Nlc3Muc3Bhd25TeW5jKG5wbUNvbW1hbmQsIFsnZ2V0JywgJ3ByZWZpeCddLCB7XG4gICAgICAgIGVudjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9jZXNzLmVudiksIHsgUEFUSDogZ2V0UGF0aCgpIH0pXG4gICAgICB9KS5vdXRwdXRbMV0udG9TdHJpbmcoKS50cmltKClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zdCBlcnJNc2cgPSAnVW5hYmxlIHRvIGV4ZWN1dGUgYG5wbSBnZXQgcHJlZml4YC4gUGxlYXNlIG1ha2Ugc3VyZSAnXG4gICAgICAgICsgJ0F0b20gaXMgZ2V0dGluZyAkUEFUSCBjb3JyZWN0bHkuJ1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIENhY2hlLk5PREVfUFJFRklYX1BBVEhcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RvcnkoZGlyUGF0aCkge1xuICBsZXQgaXNEaXJcbiAgdHJ5IHtcbiAgICBpc0RpciA9IGZzLnN0YXRTeW5jKGRpclBhdGgpLmlzRGlyZWN0b3J5KClcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlzRGlyID0gZmFsc2VcbiAgfVxuICByZXR1cm4gaXNEaXJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRFU0xpbnREaXJlY3RvcnkobW9kdWxlc0RpciwgY29uZmlnLCBwcm9qZWN0UGF0aCkge1xuICBsZXQgZXNsaW50RGlyID0gbnVsbFxuICBsZXQgbG9jYXRpb25UeXBlID0gbnVsbFxuICBpZiAoY29uZmlnLmdsb2JhbC51c2VHbG9iYWxFc2xpbnQpIHtcbiAgICBsb2NhdGlvblR5cGUgPSAnZ2xvYmFsJ1xuICAgIGNvbnN0IGNvbmZpZ0dsb2JhbCA9IGNsZWFuUGF0aChjb25maWcuZ2xvYmFsLmdsb2JhbE5vZGVQYXRoKVxuICAgIGNvbnN0IHByZWZpeFBhdGggPSBjb25maWdHbG9iYWwgfHwgZ2V0Tm9kZVByZWZpeFBhdGgoKVxuICAgIC8vIE5QTSBvbiBXaW5kb3dzIGFuZCBZYXJuIG9uIGFsbCBwbGF0Zm9ybXNcbiAgICBlc2xpbnREaXIgPSBQYXRoLmpvaW4ocHJlZml4UGF0aCwgJ25vZGVfbW9kdWxlcycsICdlc2xpbnQnKVxuICAgIGlmICghaXNEaXJlY3RvcnkoZXNsaW50RGlyKSkge1xuICAgICAgLy8gTlBNIG9uIHBsYXRmb3JtcyBvdGhlciB0aGFuIFdpbmRvd3NcbiAgICAgIGVzbGludERpciA9IFBhdGguam9pbihwcmVmaXhQYXRoLCAnbGliJywgJ25vZGVfbW9kdWxlcycsICdlc2xpbnQnKVxuICAgIH1cbiAgfSBlbHNlIGlmICghY29uZmlnLmFkdmFuY2VkLmxvY2FsTm9kZU1vZHVsZXMpIHtcbiAgICBsb2NhdGlvblR5cGUgPSAnbG9jYWwgcHJvamVjdCdcbiAgICBlc2xpbnREaXIgPSBQYXRoLmpvaW4obW9kdWxlc0RpciB8fCAnJywgJ2VzbGludCcpXG4gIH0gZWxzZSBpZiAoUGF0aC5pc0Fic29sdXRlKGNsZWFuUGF0aChjb25maWcuYWR2YW5jZWQubG9jYWxOb2RlTW9kdWxlcykpKSB7XG4gICAgbG9jYXRpb25UeXBlID0gJ2FkdmFuY2VkIHNwZWNpZmllZCdcbiAgICBlc2xpbnREaXIgPSBQYXRoLmpvaW4oY2xlYW5QYXRoKGNvbmZpZy5hZHZhbmNlZC5sb2NhbE5vZGVNb2R1bGVzKSwgJ2VzbGludCcpXG4gIH0gZWxzZSB7XG4gICAgbG9jYXRpb25UeXBlID0gJ2FkdmFuY2VkIHNwZWNpZmllZCdcbiAgICBlc2xpbnREaXIgPSBQYXRoLmpvaW4ocHJvamVjdFBhdGggfHwgJycsIGNsZWFuUGF0aChjb25maWcuYWR2YW5jZWQubG9jYWxOb2RlTW9kdWxlcyksICdlc2xpbnQnKVxuICB9XG5cbiAgaWYgKGlzRGlyZWN0b3J5KGVzbGludERpcikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogZXNsaW50RGlyLFxuICAgICAgdHlwZTogbG9jYXRpb25UeXBlLFxuICAgIH1cbiAgfVxuXG4gIGlmIChjb25maWcuZ2xvYmFsLnVzZUdsb2JhbEVzbGludCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRVNMaW50IG5vdCBmb3VuZCwgcGxlYXNlIGVuc3VyZSB0aGUgZ2xvYmFsIE5vZGUgcGF0aCBpcyBzZXQgY29ycmVjdGx5LicpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGg6IENhY2hlLkVTTElOVF9MT0NBTF9QQVRILFxuICAgIHR5cGU6ICdidW5kbGVkIGZhbGxiYWNrJyxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RVNMaW50RnJvbURpcmVjdG9yeShtb2R1bGVzRGlyLCBjb25maWcsIHByb2plY3RQYXRoKSB7XG4gIGNvbnN0IHsgcGF0aDogRVNMaW50RGlyZWN0b3J5IH0gPSBmaW5kRVNMaW50RGlyZWN0b3J5KG1vZHVsZXNEaXIsIGNvbmZpZywgcHJvamVjdFBhdGgpXG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1keW5hbWljLXJlcXVpcmVcbiAgICByZXR1cm4gcmVxdWlyZShFU0xpbnREaXJlY3RvcnkpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoY29uZmlnLmdsb2JhbC51c2VHbG9iYWxFc2xpbnQgJiYgZS5jb2RlID09PSAnTU9EVUxFX05PVF9GT1VORCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRVNMaW50IG5vdCBmb3VuZCwgdHJ5IHJlc3RhcnRpbmcgQXRvbSB0byBjbGVhciBjYWNoZXMuJylcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1keW5hbWljLXJlcXVpcmVcbiAgICByZXR1cm4gcmVxdWlyZShDYWNoZS5FU0xJTlRfTE9DQUxfUEFUSClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVmcmVzaE1vZHVsZXNQYXRoKG1vZHVsZXNEaXIpIHtcbiAgaWYgKENhY2hlLkxBU1RfTU9EVUxFU19QQVRIICE9PSBtb2R1bGVzRGlyKSB7XG4gICAgQ2FjaGUuTEFTVF9NT0RVTEVTX1BBVEggPSBtb2R1bGVzRGlyXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9QQVRIID0gbW9kdWxlc0RpciB8fCAnJ1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgIHJlcXVpcmUoJ21vZHVsZScpLk1vZHVsZS5faW5pdFBhdGhzKClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RVNMaW50SW5zdGFuY2UoZmlsZURpciwgY29uZmlnLCBwcm9qZWN0UGF0aCkge1xuICBjb25zdCBtb2R1bGVzRGlyID0gUGF0aC5kaXJuYW1lKGZpbmRDYWNoZWQoZmlsZURpciwgJ25vZGVfbW9kdWxlcy9lc2xpbnQnKSB8fCAnJylcbiAgcmVmcmVzaE1vZHVsZXNQYXRoKG1vZHVsZXNEaXIpXG4gIHJldHVybiBnZXRFU0xpbnRGcm9tRGlyZWN0b3J5KG1vZHVsZXNEaXIsIGNvbmZpZywgcHJvamVjdFBhdGgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb25maWdQYXRoKGZpbGVEaXIpIHtcbiAgY29uc3QgY29uZmlnRmlsZSA9IGZpbmRDYWNoZWQoZmlsZURpciwgW1xuICAgICcuZXNsaW50cmMuanMnLCAnLmVzbGludHJjLnlhbWwnLCAnLmVzbGludHJjLnltbCcsICcuZXNsaW50cmMuanNvbicsICcuZXNsaW50cmMnLCAncGFja2FnZS5qc29uJ1xuICBdKVxuICBpZiAoY29uZmlnRmlsZSkge1xuICAgIGlmIChQYXRoLmJhc2VuYW1lKGNvbmZpZ0ZpbGUpID09PSAncGFja2FnZS5qc29uJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1keW5hbWljLXJlcXVpcmVcbiAgICAgIGlmIChyZXF1aXJlKGNvbmZpZ0ZpbGUpLmVzbGludENvbmZpZykge1xuICAgICAgICByZXR1cm4gY29uZmlnRmlsZVxuICAgICAgfVxuICAgICAgLy8gSWYgd2UgYXJlIGhlcmUsIHdlIGZvdW5kIGEgcGFja2FnZS5qc29uIHdpdGhvdXQgYW4gZXNsaW50IGNvbmZpZ1xuICAgICAgLy8gaW4gYSBkaXIgd2l0aG91dCBhbnkgb3RoZXIgZXNsaW50IGNvbmZpZyBmaWxlc1xuICAgICAgLy8gKGJlY2F1c2UgJ3BhY2thZ2UuanNvbicgaXMgbGFzdCBpbiB0aGUgY2FsbCB0byBmaW5kQ2FjaGVkKVxuICAgICAgLy8gU28sIGtlZXAgbG9va2luZyBmcm9tIHRoZSBwYXJlbnQgZGlyZWN0b3J5XG4gICAgICByZXR1cm4gZ2V0Q29uZmlnUGF0aChQYXRoLnJlc29sdmUoUGF0aC5kaXJuYW1lKGNvbmZpZ0ZpbGUpLCAnLi4nKSlcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZ0ZpbGVcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVsYXRpdmVQYXRoKGZpbGVEaXIsIGZpbGVQYXRoLCBjb25maWcsIHByb2plY3RQYXRoKSB7XG4gIGNvbnN0IGlnbm9yZUZpbGUgPSBjb25maWcuYWR2YW5jZWQuZGlzYWJsZUVzbGludElnbm9yZSA/IG51bGwgOiBmaW5kQ2FjaGVkKGZpbGVEaXIsICcuZXNsaW50aWdub3JlJylcblxuICAvLyBJZiB3ZSBjYW4gZmluZCBhbiAuZXNsaW50aWdub3JlIGZpbGUsIHdlIGNhbiBzZXQgY3dkIHRoZXJlXG4gIC8vIChiZWNhdXNlIHRoZXkgYXJlIGV4cGVjdGVkIHRvIGJlIGF0IHRoZSBwcm9qZWN0IHJvb3QpXG4gIGlmIChpZ25vcmVGaWxlKSB7XG4gICAgY29uc3QgaWdub3JlRGlyID0gUGF0aC5kaXJuYW1lKGlnbm9yZUZpbGUpXG4gICAgcHJvY2Vzcy5jaGRpcihpZ25vcmVEaXIpXG4gICAgcmV0dXJuIFBhdGgucmVsYXRpdmUoaWdub3JlRGlyLCBmaWxlUGF0aClcbiAgfVxuICAvLyBPdGhlcndpc2UsIHdlJ2xsIHNldCB0aGUgY3dkIHRvIHRoZSBhdG9tIHByb2plY3Qgcm9vdCBhcyBsb25nIGFzIHRoYXQgZXhpc3RzXG4gIGlmIChwcm9qZWN0UGF0aCkge1xuICAgIHByb2Nlc3MuY2hkaXIocHJvamVjdFBhdGgpXG4gICAgcmV0dXJuIFBhdGgucmVsYXRpdmUocHJvamVjdFBhdGgsIGZpbGVQYXRoKVxuICB9XG4gIC8vIElmIGFsbCBlbHNlIGZhaWxzLCB1c2UgdGhlIGZpbGUgbG9jYXRpb24gaXRzZWxmXG4gIHByb2Nlc3MuY2hkaXIoZmlsZURpcilcbiAgcmV0dXJuIFBhdGguYmFzZW5hbWUoZmlsZVBhdGgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDTElFbmdpbmVPcHRpb25zKHR5cGUsIGNvbmZpZywgcnVsZXMsIGZpbGVQYXRoLCBmaWxlRGlyLCBnaXZlbkNvbmZpZ1BhdGgpIHtcbiAgY29uc3QgY2xpRW5naW5lQ29uZmlnID0ge1xuICAgIHJ1bGVzLFxuICAgIGlnbm9yZTogIWNvbmZpZy5hZHZhbmNlZC5kaXNhYmxlRXNsaW50SWdub3JlLFxuICAgIGZpeDogdHlwZSA9PT0gJ2ZpeCdcbiAgfVxuXG4gIGNvbnN0IGlnbm9yZUZpbGUgPSBjb25maWcuYWR2YW5jZWQuZGlzYWJsZUVzbGludElnbm9yZSA/IG51bGwgOiBmaW5kQ2FjaGVkKGZpbGVEaXIsICcuZXNsaW50aWdub3JlJylcbiAgaWYgKGlnbm9yZUZpbGUpIHtcbiAgICBjbGlFbmdpbmVDb25maWcuaWdub3JlUGF0aCA9IGlnbm9yZUZpbGVcbiAgfVxuXG4gIGNsaUVuZ2luZUNvbmZpZy5ydWxlUGF0aHMgPSBjb25maWcuYWR2YW5jZWQuZXNsaW50UnVsZXNEaXJzLm1hcCgocGF0aCkgPT4ge1xuICAgIGNvbnN0IHJ1bGVzRGlyID0gY2xlYW5QYXRoKHBhdGgpXG4gICAgaWYgKCFQYXRoLmlzQWJzb2x1dGUocnVsZXNEaXIpKSB7XG4gICAgICByZXR1cm4gZmluZENhY2hlZChmaWxlRGlyLCBydWxlc0RpcilcbiAgICB9XG4gICAgcmV0dXJuIHJ1bGVzRGlyXG4gIH0pLmZpbHRlcihwYXRoID0+IHBhdGgpXG5cbiAgaWYgKGdpdmVuQ29uZmlnUGF0aCA9PT0gbnVsbCAmJiBjb25maWcuZ2xvYmFsLmVzbGludHJjUGF0aCkge1xuICAgIC8vIElmIHdlIGRpZG4ndCBmaW5kIGEgY29uZmlndXJhdGlvbiB1c2UgdGhlIGZhbGxiYWNrIGZyb20gdGhlIHNldHRpbmdzXG4gICAgY2xpRW5naW5lQ29uZmlnLmNvbmZpZ0ZpbGUgPSBjbGVhblBhdGgoY29uZmlnLmdsb2JhbC5lc2xpbnRyY1BhdGgpXG4gIH1cblxuICByZXR1cm4gY2xpRW5naW5lQ29uZmlnXG59XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBvZiBydWxlcyB1c2VkIGZvciBhIGxpbnQgam9iXG4gKiBAcGFyYW0gIHtPYmplY3R9IGNsaUVuZ2luZSBUaGUgQ0xJRW5naW5lIGluc3RhbmNlIHVzZWQgZm9yIHRoZSBsaW50IGpvYlxuICogQHJldHVybiB7TWFwfSAgICAgICAgICAgICAgQSBNYXAgb2YgdGhlIHJ1bGVzIHVzZWQsIHJ1bGUgbmFtZXMgYXMga2V5cywgcnVsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyBhcyB0aGUgY29udGVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSdWxlcyhjbGlFbmdpbmUpIHtcbiAgLy8gUHVsbCB0aGUgbGlzdCBvZiBydWxlcyB1c2VkIGRpcmVjdGx5IGZyb20gdGhlIENMSUVuZ2luZVxuICAvLyBBZGRlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9wdWxsLzk3ODJcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjbGlFbmdpbmUsICdnZXRSdWxlcycpKSB7XG4gICAgcmV0dXJuIGNsaUVuZ2luZS5nZXRSdWxlcygpXG4gIH1cblxuICAvLyBBdHRlbXB0IHRvIHVzZSB0aGUgaW50ZXJuYWwgKHVuZG9jdW1lbnRlZCkgYGxpbnRlcmAgaW5zdGFuY2UgYXR0YWNoZWQgdG9cbiAgLy8gdGhlIENMSUVuZ2luZSB0byBnZXQgdGhlIGxvYWRlZCBydWxlcyAoaW5jbHVkaW5nIHBsdWdpbiBydWxlcykuXG4gIC8vIEFkZGVkIGluIEVTTGludCB2NFxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNsaUVuZ2luZSwgJ2xpbnRlcicpKSB7XG4gICAgcmV0dXJuIGNsaUVuZ2luZS5saW50ZXIuZ2V0UnVsZXMoKVxuICB9XG5cbiAgLy8gT2xkZXIgdmVyc2lvbnMgb2YgRVNMaW50IGRvbid0IChlYXNpbHkpIHN1cHBvcnQgZ2V0dGluZyBhIGxpc3Qgb2YgcnVsZXNcbiAgcmV0dXJuIG5ldyBNYXAoKVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGV4aXRpbmcgcnVsZSBsaXN0IGFuZCBhIG5ldyBydWxlIGxpc3QsIGRldGVybWluZXMgd2hldGhlciB0aGVyZVxuICogaGF2ZSBiZWVuIGNoYW5nZXMuXG4gKiBOT1RFOiBUaGlzIG9ubHkgYWNjb3VudHMgZm9yIHByZXNlbmNlIG9mIHRoZSBydWxlcywgY2hhbmdlcyB0byB0aGVpciBtZXRhZGF0YVxuICogYXJlIG5vdCB0YWtlbiBpbnRvIGFjY291bnQuXG4gKiBAcGFyYW0gIHtNYXB9IG5ld1J1bGVzICAgICBBIE1hcCBvZiB0aGUgbmV3IHJ1bGVzXG4gKiBAcGFyYW0gIHtNYXB9IGN1cnJlbnRSdWxlcyBBIE1hcCBvZiB0aGUgY3VycmVudCBydWxlc1xuICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAgICAgICAgV2hldGhlciBvciBub3QgdGhlcmUgd2VyZSBjaGFuZ2VzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWRSdWxlc0NoYW5nZShjdXJyZW50UnVsZXMsIG5ld1J1bGVzKSB7XG4gIHJldHVybiAhKGN1cnJlbnRSdWxlcy5zaXplID09PSBuZXdSdWxlcy5zaXplXG4gICAgJiYgQXJyYXkuZnJvbShjdXJyZW50UnVsZXMua2V5cygpKS5ldmVyeShydWxlSWQgPT4gbmV3UnVsZXMuaGFzKHJ1bGVJZCkpKVxufVxuIl19